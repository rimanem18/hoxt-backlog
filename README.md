## Hoxt-backlog

ドメイン駆動設計とクリーンアーキテクチャです。Backlog、BacklogItem、Task の3つの集約構造を目指します。  
まずは ToDo アプリを作り、その後、バックログ管理アプリに成長させる予定です。

### コンテナ
- Docker v28.1
- Docker Compose v2.35

### ライブラリ・フレームワーク

| カテゴリ | 名前 | バージョン | 用途 |
|---------|------|-----------|------|
| **ランタイム** | Bun | 1.2 | JavaScript/TypeScript ランタイム・パッケージマネージャー |
| **フロントエンド** | Next.js | 15.4 | React フレームワーク |
| | TanStack Query | 5.84 | データフェッチ・キャッシュ管理 |
| | Tailwind CSS | 4 | CSS フレームワーク |
| **バックエンド** | Hono | 4.9 | 軽量 Web フレームワーク |
| | Drizzle ORM | 0.44 | TypeScript ORM |
| | Supabase | 2.44 | 認証・データベースサービス |
| **スキーマ** | Zod | 4.0 | TypeScript スキーマ検証 |
| | drizzle-zod | 0.8 | Drizzle と Zod の統合 |
| **開発ツール** | TypeScript | 5 | 型安全性 |
| | Biome | 2.1 | リンター・フォーマッター |
| | uuid | 11.1 | UUID 生成 |

### 技術選定理由

クラスメソッド社の AI駆動開発支援フレームワーク [tsumiki](https://github.com/classmethod/tsumiki) を前提とした AI 駆動開発と、ドメイン駆動設計 + クリーンアーキテクチャを中核に据えた開発。

- 開発効率を重視して Bun を採用。
  - 本番環境は安定性を最優先に Node.js で運用した。
  - CI では E2E を Playwright 公式コンテナを使って Node で回すことで、Bun 開発環境と本番環境の差異を事前に検知できるようにした。この戦略で、開発体験と本番安定性の両立を実現。
- コード自動生成を前提にしたためシンプルなユーティリティフレームワークである Tailwind CSS を優先。
- fetch API 準拠・軽量・高速で、AWS Lambda や Cloudflare Workers へそのままデプロイ可能、どちらにも公式対応している Hono を選択。
- バックエンドとフロントエンドともに TypeScript を採用、Zod ライブラリを導入し、VSCode での API 通信処理記述の開発体験向上を実現。型安全かつ予測変換によって、生成 AI が問題を引き起こした際の人間側の修正の負担を軽減。
- Prisma より薄い抽象で DDD の分離を阻害しにくく、Zod とも親和性の高い Drizzle を採用。
- 運用コスト削減だけでなく、Auth と RLS を統合しアプリ側の認可処理を最小化できるため Supabase を選んだ。

### 所感や感想

Claude Code の output-style に Learning（学習モード）が実装されたタイミングが重なったのもあり、全体的に良い経験になった。  

#### よかったところ

gemini MCP や o3 MCP で検索や思考を外部に投げたり、serena MCP で構造的に探索させることで、 Claude Code が消費するトークンを削減し、Max プランでなくとも安定した開発ができた。  
Tailwind CSS を AI 生成に任せた点に関して、ユーティリティクラス中心なので生成結果が壊れにくく、生成結果を人間が修正しやすい体感だった。  
また、 Hono がプレゼンテーション層にとどまり、Drizzle がインフラ層にとどまる、といったような、クリーンアーキテクチャの思想を壊さない運用がしやすかった。とくに Prisma ではなく Drizzle を選択した判断によって、Usecase までクライアントが漏れることがなく、リポジトリの段階で閉じることができた体験はとてもうれしかった。  
仕様がコードレベルで固まりやすいドメイン駆動設計に対して、Tsumiki の仕様駆動 + AI 駆動が非常にマッチしているのが身を持って感じることができた。  
それに伴い、バイブコーディングだとコード生成のたびに gemini MCP を使用していた印象だったが、仕様が固まっていたからか、コーディング中の Claude Code の思考や gemini MCP, o3 MCP の使用はほとんどなかった。  
逆に要件定義・技術設計の時点でそれらを活用した Claude Code の思考が多かったものの、tsumiki を活かすことができている実感があってよかった。  
gh コマンドで Claude Code からプルリクを作成できるカスタムスラッシュコマンドを作って diff の確認まで任せたことでテンプレートに則ったプルリクをシームレスに出すことができた。

#### 大変だったところ

PostgreSQL の RLS の理解は難しかったが、DB 側で認可を強制できる仕組みは強力で、セキュリティ設計の勉強にもなった。  
一ファイルに対して数千行を超える長大なテストファイルを生成されてしまったのは大変だった。今まで大規模な開発に取り組んでこなかった自分にとって、ファイルの分割の対応は苦戦を強いられた。テストファイルの分割について調査している間に、SUT パターンを知ることができ、それを取り入れて対応できた。   
Terraform を使ったのは初めてで、とくにロールの取り扱いに苦戦した。作成・削除といった強めの権限が必要になるため、ポリシーのリソースの制限などのセキュリティのベストプラクティスを模索した。結果、ロールが何も紐つけられていない IAM ユーザを作成してアクセスキーを発行し、このプロジェクトでのみ利用するリソースのプレフィックスがついた操作ができるロールを引き受けることで、セキュリティリスクの最小化を目指した。しかし、それでもロールの作成などの権限がついてしまうとリスクがついてくると考えたため、作成は手動でおこない、 terraform に import して更新していく形に落ち着いた。  
Cloudflare Pages のトークンの権限についても同様で、DNS が編集できる権限はリスクが高すぎると考えたため、プロジェクトの作成や DNS 設定は手動でおこない、他の部分を更新できるトークンにとどめた。  

### 起動方法

コンテナをビルド
```sh
make build
```

コンテナを起動
```sh
make up
```

サーバーからフェッチした文字列で、鮮やかな Hello World が表示されます。

<img width="1143" height="346" alt="image" src="https://github.com/user-attachments/assets/65dd41c0-4ca7-4558-ae87-197347bda2c8" />

コンテナを終了
```sh
make down
```
