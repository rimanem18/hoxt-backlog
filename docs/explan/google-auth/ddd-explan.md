# Google認証機能の業務視点解説

## 1. システムの業務目的と価値

### ユーザーにとっての価値
- **ワンクリックログイン**: Googleアカウントでパスワード無しで即座にアプリを利用開始
- **安心・安全**: 大手Google認証基盤の信頼性により、個人情報の漏洩リスクを軽減
- **シームレス体験**: 複数デバイスで同じアカウントを使い分けて、どこからでも同じ体験

### 事業者（私たち）にとっての価値
- **開発コスト削減**: パスワード管理・メール認証などの複雑な認証機能を自社開発しなくて済む
- **セキュリティリスク軽減**: Googleの認証基盤に任せることで、認証周りの脆弱性対策が不要
- **ユーザー獲得促進**: 面倒な会員登録なしで利用できるため、ユーザーの離脱率を下げる

## 2. 業務の関係者と役割

### 主要な関係者

#### エンドユーザー（お客様）
- **役割**: サービスを実際に利用する人
- **やりたいこと**: 面倒な手続きなしですぐにサービスを使い始めたい
- **心配事**: 個人情報が悪用されないか、安全にログアウトできるか

#### Googleさん（認証プロバイダー）
- **役割**: ユーザーの身元確認を代行してくれる信頼できる第三者
- **提供するもの**: ユーザーの本人確認、基本プロフィール情報（名前・メール・写真）
- **お約束**: 「この人は確かに○○さんですよ」という証明書（JWT）を発行

#### 我らがアプリケーション
- **フロントエンド（お客様の窓口）**: お客様が直接触るブラウザ画面
- **バックエンド（裏方業務）**: お客様情報の管理、各種データ処理を行う業務システム

## 3. 業務手順とフロー

### 初回利用時の流れ（新規顧客獲得）

1. **お客様がサービスを発見**
   - サイトにアクセス → 「Googleでログイン」ボタンが目に入る

2. **Google認証への案内**
   - ボタンをクリック → Googleの認証画面に自動転送（弊社サイトを離れる）

3. **Googleでの本人確認**
   - お客様がGoogleアカウントでログイン（パスワード入力）
   - 「このアプリに情報提供していいですか？」の確認

4. **認証情報の受け取り**
   - Google: 「この人は○○さんで間違いありません」の証明書を発行
   - 弊社サイトに戻ってくる + 証明書を自動受け取り

5. **顧客情報の初回登録**
   - 弊社システムで新規顧客として自動登録（名前・メール・写真をGoogleから取得）
   - これが **「JIT（Just-In-Time）プロビジョニング」** = その場で即座に顧客登録

6. **サービス利用開始**
   - お客様専用画面を表示、すぐにサービス利用可能

### 再訪時の流れ（リピーター対応）

1. **お客様の再訪問**
   - 前回ログインから時間が経過している状態でアクセス

2. **自動ログイン状態確認**
   - 弊社システムで「前回の証明書がまだ有効かな？」をチェック
   - 有効期限内 → そのままサービス利用可能
   - 期限切れ → 自動的に新しい証明書を取得（お客様に気づかれないように）

3. **必要に応じて再認証**
   - 証明書の更新ができない場合のみ、再度Googleログインをお願い

### ログアウト時の流れ

1. **お客様がログアウト操作**
   - 「ログアウト」ボタンをクリック

2. **証明書の無効化**
   - 弊社側で証明書を破棄
   - Google側にも「この人のログアウト処理完了」を通知

3. **安全な状態に復帰**
   - ログイン前の画面に戻る
   - 以降、再度認証なしにはサービス利用不可

## 4. DDDでの考え方

### なぜDDD（ドメイン駆動設計）を使うのか？

**例え話**: レストランの経営に例えると...

- **従来のやり方**: 「注文受付」「調理」「会計」をごちゃ混ぜで一人が全部やる
- **DDDのやり方**: 「フロア担当」「キッチン担当」「経理担当」に明確に役割分担

認証機能も同じように、それぞれの**責任範囲を明確に分けて**管理します。

### 認証におけるドメイン（業務領域）の分け方

#### 1. ユーザー管理ドメイン
**業務的な意味**: 「お客様情報の管理」
- **何をするか**: お客様の基本情報（名前・メール・プロフィール）を管理
- **ビジネスルール例**: 
  - 同じメールアドレスで複数のアカウントは作れない
  - アカウント無効化されたお客様はサービス利用不可
  - プロフィール更新は本人のみ可能

#### 2. 認証・セッション管理ドメイン
**業務的な意味**: 「お客様の利用資格の確認」
- **何をするか**: 「この人は本当にお客様なのか？」「利用権限があるのか？」を管理
- **ビジネスルール例**: 
  - 同時ログイン数は最大5台まで
  - セッション有効期限は24時間
  - 怪しいアクセスはブロック

## 5. 層別実装解説

DDDでは建物のように**階層**で役割を分けます。下から順に：

### Infrastructure層（地下1階：インフラ・設備）
**業務的な意味**: 「建物の基盤設備」

実際の**外部システムとの接続**を担当：

```typescript
/**
 * Supabaseとの実際の通信を行う
 * 
 * なぜここに書く？
 * - 外部システム（Supabase、Google）は変更される可能性がある
 * - ビジネスロジックから切り離すことで、システム変更に強くなる
 */
class SupabaseAuthProvider implements IAuthProvider {
  /**
   * Googleから受け取った証明書が本物かどうかチェック
   * 
   * やりがちなミス: ここでビジネスルール（「同時ログイン数制限」など）
   * を書いてしまう → 正解は上の層で処理
   */
  async validateToken(token: string): Promise<AuthenticatedUser> {
    // Supabaseに「この証明書、本物？」を問い合わせ
    const { data, error } = await this.supabase.auth.getUser(token);
    
    // 技術的エラーのみここで処理
    if (error) throw new InvalidTokenError('access', error);
    
    // 単純なデータ変換のみ
    return this.convertToInternalFormat(data.user);
  }
}
```

### Domain層（1階：業務ルール）
**業務的な意味**: 「お店の営業ルール・方針」

**最も重要**: ビジネスルールの中枢部分：

```typescript
/**
 * ユーザー集約 - お客様情報の管理責任者
 * 
 * 集約 = 「関連する業務をまとめて管理する責任者」
 * レストランで言う「フロアマネージャー」のような存在
 */
class UserAggregate {
  private user: User;
  private sessions: AuthSession[] = [];
  
  /**
   * セッション付きでの認証処理
   * 
   * ここがビジネスルール！
   * なぜここに書く？業務要件「同時ログイン数は5台まで」を守るため
   */
  authenticateWithSession(session: AuthSession, maxSessions = 5): void {
    // ビジネスルール: 同時ログイン制限
    if (this.sessions.length >= maxSessions) {
      // 古いセッションを自動削除（業務判断）
      this.removeOldestSession();
    }
    
    // 新しいセッションを追加
    this.sessions.push(session);
    
    // 業務イベント発生「お客様がログインした」
    this.addDomainEvent(new UserLoggedInEvent(this.user.id, this.user, session));
  }
  
  /**
   * やりがちなミス: ここでデータベース操作を直接書く
   * 正解: 業務ルールのみに集中、データ保存は上の層に任せる
   */
}
```

### Application層（2階：業務手順）
**業務的な意味**: 「接客手順・オペレーション」

お客様からのリクエストを受けて、**業務手順**を実行：

```typescript
/**
 * ユーザー認証ユースケース
 * 
 * ユースケース = 「お客様からの一連の要求への対応手順」
 * 「ログインしたいです」→「はい、こちらが手順です」
 */
class AuthenticateUserUseCase {
  /**
   * ログイン処理の一連の手順
   * 
   * なぜこの順番？ 業務として自然な流れだから
   */
  async execute(jwtPayload: any): Promise<AuthenticateUserResult> {
    try {
      // 1. 証明書の確認（Googleに問い合わせ）
      const authenticatedUser = await this.authProvider.validateToken(jwtPayload);
      
      // 2. お客様情報の確認・準備
      let userAggregate = await this.userRepository.findByAuthProviderId(
        authenticatedUser.authProviderUserId
      );
      
      // 3. 新規お客様の場合は初回登録（JIT Provisioning）
      if (!userAggregate) {
        userAggregate = await this.createNewUserAggregate(authenticatedUser);
      }
      
      // 4. ログイン処理（ビジネスルール適用）
      userAggregate.authenticateWithSession(authenticatedUser.session);
      
      // 5. お客様情報の保存
      await this.userRepository.save(userAggregate);
      
      // 6. 関係部署への通知（イベント発行）
      await this.publishEvents(userAggregate.getAndClearDomainEvents());
      
      return AuthenticateUserResult.success(userAggregate.user);
      
    } catch (error) {
      // エラーが起きた時の業務対応
      return AuthenticateUserResult.failure(error);
    }
  }
}
```

### Presentation層（3階：お客様対応）
**業務的な意味**: 「受付・接客窓口」

お客様と直接やりとりする部分：

```typescript
/**
 * 認証コントローラー
 * 
 * お客様からのリクエストを受け取り、適切な部署に案内
 */
class AuthController {
  /**
   * 「ログイン状況を教えて」というお客様の質問への対応
   */
  async getMe(c: Context) {
    try {
      // 1. お客様の証明書を確認
      const token = c.get('jwtPayload');
      
      // 2. 業務部署（Application層）に処理を依頼
      const result = await this.authenticateUserUseCase.execute(token);
      
      // 3. 結果をお客様にお返し
      if (result.success) {
        return c.json({
          success: true,
          data: { user: result.data }
        });
      } else {
        throw result.error;
      }
      
    } catch (error) {
      // エラー時の丁寧な対応
      return c.json({
        success: false,
        error: {
          code: 'AUTHENTICATION_FAILED',
          message: '認証に失敗しました。再度ログインしてください。'
        }
      }, 401);
    }
  }
}
```

### なぜこの分け方？

**レストランの例で理解**:
- **受付（Presentation）**: お客様対応、注文受付
- **フロアマネージャー（Application）**: 注文の流れを管理、各部署への指示
- **シェフ（Domain）**: 料理の作り方、品質基準の管理
- **倉庫管理（Infrastructure）**: 食材の仕入れ、在庫管理

**各層が独立している利点**:
- **変更に強い**: レシピ（Domain）を変えずに、仕入れ先（Infrastructure）を変更可能
- **テストしやすい**: フロアマネージャー（Application）の手順だけを単体でテスト可能
- **理解しやすい**: それぞれの責任が明確で、新人も理解しやすい

## 6. 実装の進め方

### ステップ1: ドメインから始める（一番重要な部分）

```typescript
// まず「業務ルール」を明確にする
class UserAggregate {
  // 「同時ログイン数制限」というビジネスルール
  // 「セッション管理」という責任
  // 「ユーザー状態の整合性」という約束
}

// よく間違える順番: データベース設計から始める
// 正しい順番: ビジネスルールから始める
```

**なぜドメインから？**
- ビジネス価値を生み出すのはここだから
- ここが間違っていると、どんなに技術が優秀でも意味がない
- 要件変更があっても、このルールが軸になる

### ステップ2: アプリケーション層で手順整理

```typescript
// 「ログインする」という業務手順を整理
class AuthenticateUserUseCase {
  // 1. 証明書確認
  // 2. ユーザー取得/作成
  // 3. セッション処理
  // 4. 保存
  // 5. イベント通知
}
```

### ステップ3: インフラ層で技術選定

```typescript
// 最後に「どの技術を使うか」を決める
class SupabaseAuthProvider {
  // Supabaseを使う技術的な実装
  // 後でAWS Cognitoに変更することも可能
}
```

### ステップ4: プレゼンテーション層でお客様対応

```typescript
// APIの形やフロントエンドの見た目
class AuthController {
  // お客様に優しいインターフェース
}
```

### よくある失敗と対策

#### 失敗例1: 技術から始めてしまう
❌ 「Supabaseを使うから、その機能に合わせて設計しよう」
✅ 「ビジネス要件を満たすには、どんな機能が必要？その後で技術選定」

#### 失敗例2: 全部を一か所に書く
❌ 「ControllerでDBアクセスもビジネスルールも全部書く」
✅ 「各層の責任を分けて、変更に強い設計にする」

#### 失敗例3: ドメインにインフラの詳細を書く
❌ 「UserAggregateでSupabaseのAPIを直接呼ぶ」
✅ 「インターフェース（契約）を使って、具体的な技術は別の層で処理」

### テスト戦略

```typescript
// ドメイン層のテスト（一番重要）
describe('UserAggregate', () => {
  test('同時ログイン数制限のテスト', () => {
    // ビジネスルールが正しく動くかテスト
  });
});

// Application層のテスト
describe('AuthenticateUserUseCase', () => {
  test('JITプロビジョニングの手順テスト', () => {
    // 業務手順が正しくできるかテスト
  });
});
```

### 段階的な実装アプローチ

1. **MVP（最小限）**: Googleログイン・ログアウトのみ
2. **機能追加**: プロフィール編集、セッション管理
3. **拡張**: 他のOAuthプロバイダー（GitHub、Twitter等）追加
4. **強化**: 監査ログ、セキュリティ機能

---

このように、DDDとクリーンアーキテクチャを使うことで：
- **理解しやすい**: 業務の関係者・手順・責任が明確
- **変更に強い**: 技術変更でもビジネスロジックは影響なし  
- **テストしやすい**: 各層を独立してテスト可能
- **チーム開発しやすい**: 責任が明確なので分担しやすい

という利点を得られます。

技術的な複雑さより、**「お客様にとって価値あるシステム」**を作ることに集中できるのが、DDD・クリーンアーキテクチャの最大のメリットです。