name: Production Deployment

on:
  push:
    branches:
      - main    # REQ-104Ê∫ñÊã†: main„Éû„Éº„Ç∏„ÅßproductionÊõ¥Êñ∞
      - HOXBL-27-main-deploy-workflow  # „ÉÜ„Çπ„ÉàÁî®: „Éñ„É©„É≥„ÉÅ„ÅßÁõ¥Êé•„ÉÜ„Çπ„Éà
  workflow_dispatch: {}  # ÊâãÂãïÂÆüË°å„Ç™„Éó„Ç∑„Éß„É≥

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: ap-northeast-1
  TERRAFORM_VERSION: 1.6.0
  NODE_VERSION: 22

jobs:
  terraform:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      has_destructive_changes: ${{ steps.plan.outputs.has_destructive_changes }}
      lambda_function_name_production: ${{ steps.tf_outputs.outputs.lambda_function_name_production }}
      lambda_function_url_production: ${{ steps.tf_outputs.outputs.lambda_function_url_production }}
      cloudflare_account_id: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
      cloudflare_project_name: ${{ vars.PROJECT_NAME }}
      aws_role_arn: ${{ steps.tf_outputs.outputs.aws_role_arn }}
      access_allow_origin_production: ${{ steps.tf_outputs.outputs.access_allow_origin_production }}
      next_public_api_base_url_production: ${{ steps.tf_outputs.outputs.next_public_api_base_url_production }}
      next_public_site_url_production: ${{ steps.tf_outputs.outputs.next_public_site_url_production }}
      next_public_trusted_domains_production: ${{ steps.tf_outputs.outputs.next_public_trusted_domains_production }}
      next_public_api_base_url_preview: ${{ steps.tf_outputs.outputs.next_public_api_base_url_preview }}
      next_public_site_url_preview: ${{ steps.tf_outputs.outputs.next_public_site_url_preview }}
      next_public_trusted_domains_preview: ${{ steps.tf_outputs.outputs.next_public_trusted_domains_preview }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Production-Terraform
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ vars.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ vars.TERRAFORM_LOCKS_TABLE }}"

      - name: Terraform Plan
        id: plan
        working-directory: ./terraform
        env:
          TF_VAR_repository_name: ${{ github.repository }}
          TF_VAR_supabase_url: ${{ vars.NEXT_PUBLIC_SUPABASE_URL }}
          TF_VAR_base_schema: app_${{ vars.PROJECT_NAME }}
          TF_VAR_project_name: ${{ vars.PROJECT_NAME }}
          TF_VAR_aws_region: ${{ vars.AWS_REGION }}
          TF_VAR_domain_name: ${{ vars.DOMAIN_NAME }}
          TF_VAR_database_url: ${{ secrets.DATABASE_URL }}
          TF_VAR_cloudflare_account_id: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_zone_id: ${{ vars.CLOUDFLARE_ZONE_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          terraform plan -detailed-exitcode -out=tfplan

          # Check for destructive changes
          if terraform show -json tfplan | jq -e '.resource_changes[]? | select(.change.actions[] | contains("delete"))' > /dev/null; then
            echo "has_destructive_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_destructive_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Log destructive changes (if detected)
        if: steps.plan.outputs.has_destructive_changes == 'true'
        run: |
          echo "‚ö†Ô∏è Destructive changes detected in Terraform plan"
          echo "Changes will be applied automatically for individual development"
          terraform show -json tfplan | jq '.resource_changes[] | select(.change.actions[] | contains("delete"))'
        working-directory: ./terraform

      - name: Terraform Apply
        working-directory: ./terraform
        env:
          TF_VAR_repository_name: ${{ github.repository }}
          TF_VAR_supabase_url: ${{ vars.NEXT_PUBLIC_SUPABASE_URL }}
          TF_VAR_base_schema: app_${{ vars.PROJECT_NAME }}
          TF_VAR_project_name: ${{ vars.PROJECT_NAME }}
          TF_VAR_aws_region: ${{ vars.AWS_REGION }}
          TF_VAR_domain_name: ${{ vars.DOMAIN_NAME }}
          TF_VAR_database_url: ${{ secrets.DATABASE_URL }}
          TF_VAR_cloudflare_account_id: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_cloudflare_zone_id: ${{ vars.CLOUDFLARE_ZONE_ID }}
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: terraform apply -auto-approve tfplan

      - name: Extract Terraform Outputs
        id: tf_outputs
        working-directory: ./terraform
        run: |
          echo "lambda_function_name_production=$(terraform output -raw lambda_production_function_name)" >> $GITHUB_OUTPUT
          echo "lambda_function_url_production=$(terraform output -raw next_public_api_base_url_production)" >> $GITHUB_OUTPUT
          echo "aws_role_arn=$(terraform output -raw github_actions_role_arn)" >> $GITHUB_OUTPUT
          echo "project_name=$(terraform output -raw project_name)" >> $GITHUB_OUTPUT
          echo "access_allow_origin_production=$(terraform output -raw access_allow_origin_production)" >> $GITHUB_OUTPUT
          echo "next_public_api_base_url_production=$(terraform output -raw next_public_api_base_url_production)" >> $GITHUB_OUTPUT
          echo "next_public_site_url_production=$(terraform output -raw next_public_site_url_production)" >> $GITHUB_OUTPUT
          echo "next_public_trusted_domains_production=$(terraform output -raw next_public_trusted_domains_production)" >> $GITHUB_OUTPUT
          echo "next_public_api_base_url_preview=$(terraform output -raw next_public_api_base_url_preview)" >> $GITHUB_OUTPUT
          echo "next_public_site_url_preview=$(terraform output -raw next_public_site_url_preview)" >> $GITHUB_OUTPUT
          echo "next_public_trusted_domains_preview=$(terraform output -raw next_public_trusted_domains_preview)" >> $GITHUB_OUTPUT

          # „Éá„Éê„ÉÉ„Ç∞Áî®„É≠„Ç∞Âá∫Âäõ
          echo "üîß Terraform Outputs extracted:"
          echo "  Lambda Function: $(terraform output -raw lambda_production_function_name)"
          echo "  Function URL: $(terraform output -raw next_public_api_base_url_production)"
          echo "  CloudFlare Account: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}"
          echo "  CloudFlare Project: $(terraform output -raw project_name)"
          echo "  CORS Origin: $(terraform output -raw access_allow_origin_production)"
          echo "  Next.js Production API: $(terraform output -raw next_public_api_base_url_production)"
          echo "  Next.js Production Site: $(terraform output -raw next_public_site_url_production)"
          echo "  Next.js Preview API: $(terraform output -raw next_public_api_base_url_preview)"
          echo "  Next.js Preview Site: $(terraform output -raw next_public_site_url_preview)"

  database:
    name: Database Migration (drizzle-kit)
    runs-on: ubuntu-latest
    needs: terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install shared-schemas dependencies
        working-directory: ./app/packages/shared-schemas
        run: bun install --frozen-lockfile

      - name: Install dependencies
        working-directory: ./app/server
        run: bun install --frozen-lockfile

      - name: Run database migration
        working-directory: ./app/server
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_MIGRATE }}
        run: bun run db:push
        timeout-minutes: 10

  backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [terraform, database]
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install shared-schemas dependencies
        working-directory: ./app/packages/shared-schemas
        run: bun install --frozen-lockfile

      - name: Install dependencies
        working-directory: ./app/server
        run: bun install --frozen-lockfile

      - name: Build for Lambda
        working-directory: ./app/server
        env:
          ACCESS_ALLOW_ORIGIN: ${{ needs.terraform.outputs.access_allow_origin_production }}
          ACCESS_ALLOW_METHODS: ${{ vars.ACCESS_ALLOW_METHODS }}
          ACCESS_ALLOW_HEADERS: ${{ vars.ACCESS_ALLOW_HEADERS }}
          # JWKSÊ§úË®ºË®≠ÂÆöÔºàÊú¨Áï™Áí∞Â¢ÉÔºâ
          USE_JWKS_VERIFIER: 'true'
          ENABLE_JWKS_VERIFICATION: 'true'
          ENABLE_HS256_FALLBACK: 'false'
        run: bun run build:lambda

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Production-Lambda
          aws-region: ${{ env.AWS_REGION }}

      - name: Package Lambda
        working-directory: ./app/server
        run: |
          # bun run build:lambda „ÅßÁîüÊàê„Åï„Çå„Åüindex.js„Å®node_modules„ÇízipÂåñ
          mkdir -p lambda-dist
          cp dist/lambda.js lambda-dist/
          cp package.json lambda-dist/
          cd lambda-dist && bun install --production
          zip -r ../lambda-deployment.zip . -x "*.map" "*.test.*" "*.dev.*"

      - name: Deploy Lambda
        run: |
          # Update function code (suppress output to prevent secret exposure)
          aws lambda update-function-code \
            --function-name ${{ needs.terraform.outputs.lambda_function_name_production }} \
            --zip-file fileb://app/server/lambda-deployment.zip \
            --output text > /dev/null

          echo "‚úÖ Function code updated successfully"

          # Wait for function update to complete before publishing version
          echo "Waiting for function update to complete..."
          aws lambda wait function-updated \
            --function-name ${{ needs.terraform.outputs.lambda_function_name_production }}

          # Publish new version and promote to stable alias
          VERSION=$(aws lambda publish-version --function-name ${{ needs.terraform.outputs.lambda_function_name_production }} --query 'Version' --output text)
          echo "PROMOTED_VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Published Lambda version: $VERSION"

          # Check if stable alias exists, create or update accordingly
          if aws lambda get-alias --function-name ${{ needs.terraform.outputs.lambda_function_name_production }} --name stable >/dev/null 2>&1; then
            echo "Updating existing stable alias to version $VERSION"
            aws lambda update-alias \
              --function-name ${{ needs.terraform.outputs.lambda_function_name_production }} \
              --name stable \
              --function-version $VERSION \
              --output text > /dev/null
          else
            echo "Creating new stable alias for version $VERSION"
            aws lambda create-alias \
              --function-name ${{ needs.terraform.outputs.lambda_function_name_production }} \
              --name stable \
              --function-version $VERSION \
              --description "Production stable deployment alias" \
              --output text > /dev/null
          fi

          echo "Successfully promoted Lambda version $VERSION to production stable alias"

  frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [backend]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install shared-schemas dependencies
        working-directory: ./app/packages/shared-schemas
        run: bun install --frozen-lockfile

      - name: Install dependencies
        working-directory: ./app/client
        run: bun install --frozen-lockfile

      - name: Build
        working-directory: ./app/client
        env:
          NEXT_PUBLIC_API_BASE_URL: ${{ needs.terraform.outputs.next_public_api_base_url_production }}
          NEXT_PUBLIC_SITE_URL: ${{ needs.terraform.outputs.next_public_site_url_production }}
          NEXT_PUBLIC_TRUSTED_DOMAINS: ${{ needs.terraform.outputs.next_public_trusted_domains_production }}
          NEXT_PUBLIC_SUPABASE_URL: ${{ vars.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ vars.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        run: bun run build

      - name: Deploy to CloudFlare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ vars.CLOUDFLARE_ACCOUNT_ID }}
          projectName: ${{ vars.PROJECT_NAME }}
          directory: ./app/client/out
          gitHubToken: ${{ secrets.GITHUB_TOKEN }}

  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [terraform, database, backend, frontend]
    if: success()

    steps:
      - name: Send Discord notification (Success)
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          curl -H "Content-Type: application/json" \
               -d '{
                 "embeds": [{
                   "title": "üöÄ Production Deployment Completed Successfully!",
                   "color": 65280,
                   "fields": [
                     {"name": "Commit", "value": "${{ github.sha }}", "inline": true},
                     {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true},
                     {"name": "Actor", "value": "${{ github.actor }}", "inline": true},
                     {"name": "Repository", "value": "${{ github.repository }}", "inline": false},
                     {"name": "Components Deployed", "value": "‚úÖ Infrastructure (Terraform)\n‚úÖ Database (drizzle-kit)\n‚úÖ Backend (AWS Lambda)\n‚úÖ Frontend (CloudFlare Pages)", "inline": false}
                   ],
                   "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%S.000Z)'"
                 }]
               }' \
               "$DISCORD_WEBHOOK_URL"

  notify-failure:
    name: Notify Deployment Failure
    runs-on: ubuntu-latest
    needs: [terraform, database, backend, frontend]
    if: failure()

    steps:
      - name: Send Discord notification (Failure)
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          curl -H "Content-Type: application/json" \
               -d '{
                 "embeds": [{
                   "title": "‚ùå Production Deployment Failed!",
                   "color": 16711680,
                   "fields": [
                     {"name": "Commit", "value": "${{ github.sha }}", "inline": true},
                     {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true},
                     {"name": "Actor", "value": "${{ github.actor }}", "inline": true},
                     {"name": "Repository", "value": "${{ github.repository }}", "inline": false},
                     {"name": "Action", "value": "Please check the [job logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details and retry the deployment.", "inline": false}
                   ],
                   "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%S.000Z)'"
                 }]
               }' \
               "$DISCORD_WEBHOOK_URL"
